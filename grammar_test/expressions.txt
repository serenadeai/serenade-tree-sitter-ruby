================
scope resolution
================

Foo::bar
::Bar

---

(program
  (scope_resolution (identifier) (identifier))
  (scope_resolution (identifier)))

============
element reference
============

foo[bar]

---

(program (element_reference (identifier) (identifier)))

============
element reference with string
============

foo["bar"]

---

(program (element_reference (identifier) (string)))

============
element reference with symbol
============

foo[:bar]

---

(program (element_reference (identifier) (symbol)))

============
element assignment
============

foo[bar] = 1

---

(program (assignment (element_reference (identifier) (identifier)) (integer)))

===============
vacuous literal
===============

()

---

(program)

===================
yield without value
===================

yield

---

(program (yield))

=====
yield
=====

yield foo
yield foo, bar

---

(program
  (yield (argument_list (identifier)))
  (yield (argument_list (identifier) (identifier))))

===
not
===

not foo

---

(program (not (identifier)))

===
and
===

foo and bar

---

(program (and (identifier) (identifier)))

===
or
===

foo or bar

---

(program (or (identifier) (identifier)))

====================
and or associativity
====================

a or b and c

---

(program (and (or (identifier) (identifier)) (identifier)))

========
defined?
========

defined? foo
defined? Foo.bar
defined?(foo)
defined?($foo)
defined?(@foo)

---

(program
  (defined (identifier))
  (defined (call (identifier) (identifier)))
  (defined (identifier))
  (defined (global_variable))
  (defined (instance_variable)))

==========
assignment
==========

x = y

---

(program (assignment (identifier) (identifier)))

==========
math assignment
==========

x += y
x -= y
x *= y
x **= y
x /= y

---

(program
  (math_assignment (identifier) (identifier))
  (math_assignment (identifier) (identifier))
  (math_assignment (identifier) (identifier))
  (math_assignment (identifier) (identifier))
  (math_assignment (identifier) (identifier)))

==========
conditional assignment
==========

x ||= y
x &&= y

---

(program
  (conditional_assignment (identifier) (identifier))
  (conditional_assignment (identifier) (identifier)))

===========
conditional
===========

a ? b : c

a ? b
  : c

---

(program
  (conditional (identifier) (identifier) (identifier))
  (conditional (identifier) (identifier) (identifier)))

===============
inclusive range
===============

a..b

---

(program (range (identifier) (identifier)))

===============
exclusive range
===============

a...b

---

(program (range (identifier) (identifier)))

==========
boolean or
==========

a || b

---

(program (boolean_or (identifier) (identifier)))

===========
boolean and
===========

a && b

---

(program (boolean_and (identifier) (identifier)))

==========
relational
==========

a == b
a != b
a === b
a <=> b
a =~ b
a !~ b

---

(program
  (relational (identifier) (identifier))
  (relational (identifier) (identifier))
  (relational (identifier) (identifier))
  (relational (identifier) (identifier))
  (relational (identifier) (identifier))
  (relational (identifier) (identifier)))

==========
comparison
==========

a < b
a <= b
a > b
a >= b

---

(program
  (comparison (identifier) (identifier))
  (comparison (identifier) (identifier))
  (comparison (identifier) (identifier))
  (comparison (identifier) (identifier)))

==========
bitwise or
==========

a | b

---

(program (bitwise_or (identifier) (identifier)))

===========
bitwise xor
===========

a ^ b

---

(program (bitwise_or (identifier) (identifier)))

===========
bitwise and
===========

a & b

---

(program (bitwise_and (identifier) (identifier)))

=====
shift
=====

a >> b
a << b

---

(program
  (shift (identifier) (identifier))
  (shift (identifier) (identifier)))

========
additive
========

a + b

---

(program (additive (identifier) (identifier)))

==============
multiplicative
==============

a * b

---

(program (multiplicative (identifier) (identifier)))

===========
unary minus
===========

-a

---

(program (unary_minus (identifier)))

===========
exponential
===========

a ** b

---

(program (exponential (identifier) (identifier)))

==========
complement
==========

!a

---

(program (complement (identifier)))

===============================
method call
===============================

foo
foo()
print "hello"
print("hello")

---

(program
  (identifier)
  (method_call (identifier) (argument_list))
  (method_call (identifier) (argument_list (string)))
  (method_call (identifier) (argument_list (string))))

===============================
method call arguments on multiple lines
===============================

foo a,
  b, c

---

(program
  (method_call
    (identifier)
    (argument_list (identifier) (identifier) (identifier))))

===============================
method call with training comma
===============================

foo(a, b,)

---

(program
  (method_call
    (identifier)
    (argument_list (identifier) (identifier))))

===============================
method call with receiver
===============================

foo.bar
foo.bar()
foo.bar "hi"
foo.bar "hi", 2
foo.bar("hi")
foo.bar("hi", 2)

---

(program
  (call (identifier) (identifier))
  (method_call (call (identifier) (identifier)) (argument_list))
  (method_call (call (identifier) (identifier)) (argument_list (string)))
  (method_call (call (identifier) (identifier)) (argument_list (string) (integer)))
  (method_call (call (identifier) (identifier)) (argument_list (string)))
  (method_call (call (identifier) (identifier)) (argument_list (string) (integer))))

===============================
method call with safe navigation operator
===============================

foo&.bar

---

(program (call (identifier) (identifier)))

===============================
method call with hash args
===============================

foo(:a => true)
foo :a => true, :c => 1

---

(program
  (method_call (identifier) (argument_list (argument_pair (symbol) (boolean))))
  (method_call (identifier) (argument_list (argument_pair (symbol) (boolean)) (argument_pair (symbol) (integer)))))

===============================
method call with keyword args
===============================

foo(a: true)
foo a: true

---

(program
  (method_call (identifier) (argument_list (argument_pair (identifier) (boolean))))
  (method_call (identifier) (argument_list (argument_pair (identifier) (boolean)))))

===============================
method call with block argument
===============================

foo(&:sort)
foo(&bar)

---

(program
  (method_call (identifier) (argument_list (block_argument (symbol))))
  (method_call (identifier) (argument_list (block_argument (identifier)))))

===============================
method call lambda argument
===============================

foo :bar, -> (a) { 1 }
foo :bar, -> (a) { where(:c => b) }

---

(program
  (method_call (identifier)
    (argument_list
      (symbol)
      (lambda (formal_parameters (identifier)) (integer))))
  (method_call (identifier)
    (argument_list
      (symbol)
      (lambda
        (formal_parameters (identifier))
        (method_call (identifier) (argument_list (argument_pair (symbol) (identifier))))))))

===============================
method call lambda argument and do block
===============================

foo :bar, -> (a) { 1 } do
end

---

(program
  (method_call (identifier)
    (argument_list (symbol) (lambda (formal_parameters (identifier)) (integer)))
    (do_block)))

============================
method call without parens
============================

include D::E.f

---

(program (method_call (identifier) (argument_list (call (scope_resolution (identifier) (identifier)) (identifier)))))

===============================
method call with block argument do end
===============================

foo do |i|
  foo
end

foo(a) do |i|
  foo
end

foo.bar a do |i|
  foo
end

foo(a) do |name: i, *args|
end

---

(program
  (method_call
    (identifier)
    (do_block (formal_parameters (identifier)) (identifier)))
  (method_call
    (identifier)
    (argument_list (identifier))
    (do_block (formal_parameters (identifier)) (identifier)))
  (method_call
    (call (identifier) (identifier))
    (argument_list (identifier))
    (do_block (formal_parameters (identifier)) (identifier)))
  (method_call
    (identifier)
    (argument_list (identifier))
    (do_block (formal_parameters (keyword_parameter (identifier) (identifier)) (splat_parameter (identifier))))))

===============================
method call with block argument curly
===============================

foo { |i| foo }
foo items.any? { |i| i > 0 }
foo(bar, baz) { quux }

---

(program
  (method_call (identifier) (block (formal_parameters (identifier)) (identifier)))
  (method_call (identifier) (argument_list (method_call
    (call (identifier) (identifier))
    (block (formal_parameters (identifier)) (comparison (identifier) (integer))))))

  (method_call
    (identifier)
    (argument_list (identifier) (identifier))
    (block (identifier))))

===============================
method call with block shadow arguments
===============================

foo { |; i, j| }

---

(program (method_call (identifier) (block (identifier) (identifier))))

==============
empty lambda expression
==============

lambda {}

---

(program (lambda))

==================
lambda expression with body
==================

lambda { foo }

---

(program (lambda (identifier)))

====================
lambda expression with an arg
====================

lambda { |foo| 1 }

---

(program (lambda (formal_parameters (identifier)) (integer)))

===========================
lambda expression with multiple args
===========================

lambda { |a, b, c|
	1
	2
}

---

(program (lambda (formal_parameters (identifier) (identifier) (identifier)) (integer) (integer)))

====================
lambda expression with do end
====================

lambda do |foo|
  1
end

---

(program (lambda (formal_parameters (identifier)) (integer)))
